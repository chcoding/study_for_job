# 进程

## 进程管理

进程提供2种虚拟机制：虚拟处理器和虚拟内存

每个进程有独立的虚拟处理器和虚拟内存，

每个线程有独立的虚拟处理器，同一个进程内的线程有可能会共享虚拟内存。



### 进程的创建

Linux中创建进程与其他系统有个主要区别，Linux中创建进程分2步：fork()和exec()。

fork: 通过拷贝当前进程创建一个子进程

exec: 读取可执行文件，将其载入到内存中运行

创建的流程：

1. 调用dup_task_struct()为新进程分配内核栈，task_struct等，其中的内容与父进程相同。
2. check新进程(进程数目是否超出上限等)
3. 清理新进程的信息(比如PID置0等)，使之与父进程区别开。
4. 新进程状态置为 TASK_UNINTERRUPTIBLE
5. 更新task_struct的flags成员。
6. 调用alloc_pid()为新进程分配一个有效的PID
7. 根据clone()的参数标志，拷贝或共享相应的信息
8. 做一些扫尾工作并返回新进程指针

创建进程的fork()函数实际上最终是调用clone()函数。



#### fork和vfork

fork函数创建进程中会为子进程复制页表等其他资源，并且通过写时复制来共享物理内存。

vfork函数甚至连页表都不拷贝了，且会阻塞父进程，直到子进程通过vfork_done指针向他发送信号。



### 线程的创建

​	Linux中把所有线程当做进程实现，内核并没有准备特别的调度算法或者定义特别的数据结构来表征线程，**线程仅仅被视为一个与其他进程共享某些资源的进程**。



创建线程和进程的步骤一样，只是最终传给clone()函数的参数不同。

比如，通过一个普通的fork来创建进程，相当于：clone(SIGCHLD, 0)

**创建一个和父进程共享地址空间，文件系统资源，文件描述符和信号处理程序的进程，即一个线程**：clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)

​	在内核中创建的内核线程与普通的进程之间还有个主要区别在于：内核线程没有独立的地址空间，它们只能在内核空间运行。

这与之前提到的Linux内核是个单内核有关。



### 进程的终止

进程终结时所需的清理工作和进程描述符的删除被分开执行。

和创建进程一样，终结一个进程同样有很多步骤：

子进程上的操作(do_exit)

1. 设置task_struct中的标识成员设置为PF_EXITING
2. 调用del_timer_sync()删除内核定时器, 确保没有定时器在排队和运行
3. 调用exit_mm()释放进程占用的mm_struct
4. 调用sem__exit()，使进程离开等待IPC信号的队列
5. 调用exit_files()和exit_fs()，释放进程占用的文件描述符和文件系统资源
6. 把task_struct的exit_code设置为进程的返回值
7. 调用exit_notify()向父进程发送信号，并把自己的状态设为EXIT_ZOMBIE
8. 切换到新进程继续执行



​	子进程进入EXIT_ZOMBIE之后，虽然永远不会被调度，与进程关联的资源也释放掉了，但是它**本身占用的内存还没有释放**，比如创建时分配的内核栈、thread_info、task_struct结构等，这些**由父进程来释放**。

父进程上的操作(release_task)

父进程受到子进程发送的exit_notify()信号后，将该子进程的进程描述符和所有进程独享的资源全部删除。



#### 孤儿进程找新的父进程

子进程在调用exit_notify()时已经考虑到了这点。

​	如果子进程的父进程已经退出了，那么子进程在退出时，exit_notify()函数会先调用`forget_original_parent()`，然后再调用find_new_reaper()来寻找新的父进程。

`find_new_reaper()`函数先在当前**线程组中找一个线程作为父亲**，如果找不到，就让init做父进程。(init进程是在linux启动时就一直存在的)



### 内核线程

​	独立运行在内核空间的标准进程，**和普通进程的区别在于内核线程没有独立的地址空间**（mm指针被设置为NULL），其值在内核空间运行，从不切换到用户空间去。

​	内核线程只能由其他内核线程创建，内核是通过kthreadd内核进程衍生出所有新的内核线程来自动处理这一点的。



## Linux进程调度

### 多任务系统

能同时并发地交互执行多个进程的操作系统



非抢占式多任务系统：

​	除非进程自己主动停止运行，否则会一直执行。

抢占式多任务系统：

​	由调度系统来决定什么时候停止一个进程的运行，以其他进程能到执行机会，进程在抢占前能够运行的时间是固定的，叫做进程的时间片。



### 进程类型

I/O消耗型和处理器消耗型

I/O消耗型进程通常都是短短运行一会，在等待I/O请求时会阻塞

处理器消耗型把时间大多用在执行代码上，调度策略往往是尽量降低调度频率，而延长运行时间。



### UNIX系统的进程调度

基于进程优先级和时间片会存在一定的问题：基于优先级存在不公平，优先级nice差1的两个进程可能分配的时间差相差很大等等。



### 完全公平调度算法CFS

​	Linux使用CFS调度器，其抢占时机取决于新的可运行程序消耗了多少**处理器使用比**，如果消耗的使用比比当前进程小，则新进程立刻投入运行，否则推迟运行。（其他系统一般取决于优先级和时间片）

#### 出发点

​	进程调度的效果应如同系统具备一个理想中的完美任务处理器，每个进程都能获得1/n的处理器时间，同时可以调度无限小的时间周期。（越小，越趋近于一个完美多任务处理器）

​	考虑到进程调度涉及到上下文切换的开销，运行周期无限小并不高效。

​	CFS允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不采用分配给每个进程时间片的做法（处理器使用比）。nice值影响是不同进程的处理器运算比。

​	CFS引入每个进程获得最小的时间片，称为最小粒度，默认情况下为1ms。



#### 实现

​	cfs定义了一种新的[模型](http://www.07net01.com/tags-模型-0.html)，它给cfs_rq（cfs的run queue）中的每一个进程安排一个**虚拟时钟，vruntime**。如果一个进程得以执行，随着时间的增长（也就是一个个tick的到来），其vruntime将不断增大，没有得到执行的进程vruntime不变。

​    而调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。

​	**CFS的核心思想就是让每个进程的vruntime互相追赶，而每个调度实体的vruntime增加速度不同，权重越大的增加的越慢，这样就能获得更多的cpu执行时间。**

​	CFS还有一个重要特点，即调度粒度小。CFS之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而CFS则在每次tick都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的[服务器](http://www.07net01.com/tags-服务器-0.html)上，通过调整调度粒度能够获得更好的调度性能。

实现方式

1. 时间记账（记录运行时间）
2. 进程选择（红黑树中找到具有最小`vruntime`的任务）
3. 调度器入口（选择最高优先级调度类中最高优先级的进程）
4. 睡眠和唤醒



#### 上下文切换

​	从一个可执行进程切换到另一个可执行进程，由contest_switch()函数负责，完成两项基本工作：

1. 把虚拟内存从上一个进程切换到新进程中
2. 把处理器状态从上一个进程切换到新进程中，包括保存旧进程、并恢复新进程的栈信息和寄存器信息，以及其他任何与体系相关的状态信息。



#### 何时调度

​	内核提供一个`need_resched`标志来表示是否需要重新执行调度。

1. 当某个进程应该被抢占时，`scheduler_tick()`会设置这个标志；
2. 当一个高优先级进程进入可执行状态时，`try_to_wake_up()`也会设置这个标志。该标志用于表示其他程序应该被运行，需要进程调度了。



##### 用户抢占

1. 从系统调用返回用户空间
2. 从中弹处理程序返回用户空间

内核会检查`need_resche`标志；如果设置，内核会在继续执行前进行调度。



##### 内核抢占

​	Linux支持内核抢占，支持在内核级任务执行的时候进行调度。但是内核调度必须在安全的情况（**当前没有持有锁的情况下**），为此内核为每个进程的`thread_info`中引入了`preempt_count`计数器用于表示锁的数量。

​	内核抢占发生在：

1. 从中断返回内核空间
2. 内核中的任务被阻塞
3. 内核显示调用`schedule()`



## 内核同步

### 锁

​	加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。

#### 互斥锁、自旋锁

​	最底层的两种就是会「互斥锁和自旋锁」

- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；



**对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的**。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，就可以继续执行。

那这个开销成本是什么呢？会有**两次线程上下文切换的成本**：

- 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
- 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。**



##### 自旋锁

​	自旋锁是通过 CPU 提供的 `CAS` 函数（*Compare And Swap*），在「用户态」完成加锁和解锁操作，**不会主动产生线程上下文切换**，所以相比互斥锁来说，会快一些，开销也小一些。

​	使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 `while` 循环等待实现，不过最好是使用 CPU 提供的 `PAUSE` 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。



#### 读写锁

读写锁的工作原理是：

- 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。



​	**读优先锁**期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。

​	而**写优先锁**是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。



#### 乐观锁、悲观锁

​	前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。

​	悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。

​	那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。

​	乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作**。



## 协程

https://zhuanlan.zhihu.com/p/463549090

https://zhuanlan.zhihu.com/p/339837580



​	**非对称协程**（asymmetric coroutines）是跟一个特定的调用者绑定的，协程让出 CPU 时，只能让回给原调用者。那到底是什么东西“不对称”呢？

其实，非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，**非对称协程只能返回最初调用它的协程。**

​	**对称协程**（symmetric coroutines）则不一样，启动之后就跟启动之前的协程没有任何关系了。协程的切换操作，一般而言只有一个操作 — yield，用于将程序控制流转移给另外的协程。**对称协程机制一般需要一个调度器的支持，按一定调度算法去选择 yield 的目标协程。**

​	Go 语言提供的协程，其实就是典型的对称协程。除了对称，Goroutines 还可以在多个线程上迁移。这种协程跟操作系统中的线程非常相似，甚至可以叫做“用户级线程”了。

​	而 libco 提供的协程，虽然编程接口跟 pthread 有点类似，“类 pthread 的接口设计”、“如线程库一样轻松”，本质上却是一种非对称协程。这一点不要被表象蒙蔽了。