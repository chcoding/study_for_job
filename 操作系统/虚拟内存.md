# 虚拟内存

## 虚拟内存

### 什么是虚拟内存？

​	虚拟内存是内存管理技术，通过对主存的抽象，它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上它通常被分割为**多个物理内存碎片（分散的物理内存）**，还有部分暂存在外部磁盘存储器上，在需要时进行数据交互。



### 虚拟内存作用

​	它为每个进程提供一个大的、一致的和私有的地址空间。

1. 它将**主存**看成**是**一个存储在**磁盘上的地址空间的高速缓存**，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式高效使用主存。（核心点）
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏（**进程隔离**）。



### 虚拟内存如何实现

​	页表、MMU（内存管理单元）的地址翻译器

​	每个虚拟页面都有缓存、未缓存和未分配三种状态

#### 页表

​	页表就是一个**页表条目（PTE） 的数组**，虚拟地址的每个页在页表中都对应唯一的PTE。每个PTE是由一个**有效位**和一个**n位地址字段**组成的。有效位表示该虚拟页面是否被缓存到主存中，设置了有效位，n位地址表示内存中**物理页的起始地址**；没有设置有效位，地址为空表示这个虚拟页还未分配，否则地址就指向该虚拟页在磁盘的起始位置。（参考CSAPP的563页）

**操作系统负责维护页表**的内容，以及在磁盘和内存之间来回传送页。



##### Q：页表有几个？存放在哪里?

1. 每个进程都有一个**独立的页表**，多个进程的虚拟页面可以**映射到同一个共享的物理页面**上（方便共享）。
2. 页表存储在**物理内存**中，需要多级页表减少页表开销。



#### 页命中、缺页

页命中：当前虚拟页已经缓存在内存中

缺页：虚拟页缓存不命中，会触发缺页中断进行页面调度，在磁盘和内存之间完成页面的交换（LRU置换算法）。



#### 地址翻译

​	地址翻译通过CPU上的内存管理单元（MMU）查询页表来完成虚拟地址到物理地址的映射。

##### 翻译过程

​	n位的虚拟地址包含两部分：一个p位的虚拟页面偏移（Virtual Page Offset，VPO）和一个n-p位的虚拟页号（Virtual Page Number，VPN）。

​	MMU利用VPN来选择适当的PTE，PTE在有效位为1时保存了物理页面的初始地址（Physic Page Number，PPN），然后结合VPO就能得到完整的物理地址了（物理页面和虚拟页面大小相同，所以页内偏移相同）。

​	如果翻译过程中，PTE有效位没有设置，触发缺页中断，完成页面只换后，再次转换物理地址。

​	通过CPU中的TLB可以加快地址翻译，TLB可以缓存PTE信息



#### 多级页表

​	每个进程的页表都是存在内存中的，会带来巨大的内存开销。

​	通过多级页表可以大幅减少内存的开销，一级页表的每个PTE负责映射虚拟地址空间一个4MB范围的页，PTE中存入首个地址，二级页表指向具体的虚拟页。只有当一级页面管理范围的页不为空（分配了），二级页表才存在。



### Linux虚拟内存系统

​	Linux系统为每个进程维护了一个单独的虚拟地址空间，包含内核虚拟内存和进程虚拟内存。

#### 内核虚拟内存

1. 对所有进程都一样的部分：包含内核中的代码和数据结构，此外某些区域被映射到所有进程共享的物理页面。
2. 与进程相关的数据结构：页表、task、mm_struct结构、内核栈。



#### 进程虚拟内存

​	Linux将虚拟内存组织成一些区域的集合，每个区域就是已经存在着的（已分配的）虚拟内存的连续片。例如：代码段、数据段、堆、栈，**每个存在的虚拟页都保存在某个区域内。**区域允许虚拟地址空间有间隙。

​	内核为系统的每个进程维护了一个单独的任务结构`task_struct`，任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用户栈的指针、可执行目标文件的名字、程序计数器）

​	`task_struct`中有一个`mm_struct`的条目，描述了虚拟内存当前状态。其中`pgd` 指向第一级页表的基址，`mmap`指向一个`vm_area_structs`的链表，链表的每个元素描述当前的一个区域。

```c
///include/linux/sched.h 

struct mm_struct {
  struct vm_area_struct * mmap;  /* 指向虚拟区间（VMA）链表 */
  rb_root_t mm_rb;         /*指向red_black树*/
  struct vm_area_struct * mmap_cache;     /* 指向最近找到的虚拟区间*/
  pgd_t * pgd;             /*指向进程的页目录*/
  atomic_t mm_users;                   /* 用户空间中的有多少用户*/                                     
  atomic_t mm_count;               /* 对"struct mm_struct"有多少引用*/                                     
  int map_count;                        /* 虚拟区间的个数*/
  struct rw_semaphore mmap_sem;
  spinlock_t page_table_lock;        /* 保护任务页表和 mm->rss */       
  struct list_head mmlist;            /*所有活动（active）mm的链表 */
  unsigned long start_code, end_code, start_data, end_data; /* 代码段、数据段 起始地址和结束地址 */
  unsigned long start_brk, brk, start_stack; /* 栈区 的起始地址，堆区 起始地址和结束地址 */
  unsigned long arg_start, arg_end, env_start, env_end; /*命令行参数 和 环境变量的 起始地址和结束地址*/
  unsigned long rss, total_vm, locked_vm;
  unsigned long def_flags;
  unsigned long cpu_vm_mask;
  unsigned long swap_address;

  unsigned dumpable:1;
  /* Architecture-specific MM context */
  mm_context_t context;
};
```

```c
<mm_types.h> 
struct vm_area_struct { 
　　struct mm_struct * vm_mm; /* 所属地址空间。 */ 
　　unsigned long vm_start; /* vm_mm内的起始地址。 */ 
　　unsigned long vm_end; /* 在vm_mm内结束地址之后的第一个字节的地址。 */ 
　　/* 各进程的虚拟内存区域链表，按地址排序 */ 
　　struct vm_area_struct *vm_next; 
　　pgprot_t vm_page_prot; /* 该虚拟内存区域的访问权限。 */ 
　　unsigned long vm_flags; /* 标志，如下列出。 */ 
　　struct rb_node vm_rb; 
　　/* 
　　对于有地址空间和后备存储器的区域来说， 
　　shared连接到address_space->i_mmap优先树，
　　或连接到悬挂在优先树结点之外、类似的一组虚拟内存区域的链表，
　　或连接到address_space->i_mmap_nonlinear链表中的虚拟内存区域。 */ 
　　union { 
　　　　struct { 
　　　　struct list_head list; 
　　　　void *parent; /* 与prio_tree_node的parent成员在内存中位于同一位置 */ 
　　　　struct vm_area_struct *head;
　　} vm_set; 
　　　　struct raw_prio_tree_node prio_tree_node; 
　　} shared; 
　　/* 
　　*在文件的某一页经过写时复制之后，文件的MAP_PRIVATE虚拟内存区域可能同时在i_mmap树和
　　*anon_vma链表中。MAP_SHARED虚拟内存区域只能在i_mmap树中。
　　*匿名的MAP_PRIVATE、栈或brk虚拟内存区域（file指针为NULL）只能处于anon_vma链表中。
　　*/ 
　　struct list_head anon_vma_node; /* 对该成员的访问通过anon_vma->lock串行化 */ 
　　struct anon_vma *anon_vma; /* 对该成员的访问通过page_table_lock串行化 */ 
　　/* 用于处理该结构的各个函数指针。 */ 
　　struct vm_operations_struct * vm_ops; 
　　/* 后备存储器的有关信息： */ 
　　unsigned long vm_pgoff; /* （vm_file内）的偏移量，单位是PAGE_SIZE，不是PAGE_CACHE_SIZE */ 
　　struct file * vm_file; /* 映射到的文件（可能是NULL）。 */ 
　　void * vm_private_data; /* vm_pte（即共享内存） */ 
};
```



![1677140340613](C:\Users\Chenhui\AppData\Roaming\Typora\typora-user-images\1677140340613.png)



### 内存映射

​	Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容。虚拟内存区域可以映射到两种类型的对象中的一种：

1. Linux文件系统中的普通文件
2. 匿名文件，由内核创建，包含的全二进制0

#### 作用

​	提供了一种清晰的机制，实现多个进程共享对象。不同进程的虚拟内存空间可以映射到同一块物理内存中。



### 写时复制

​	写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，**直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本**（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。

​	写时复制的作用在系统调用`fork`和`exec`时体现。`fork`执行后，子进程从父进程中复制一份所需要的数据结构（包括页表），并且分配唯一的pid。复制完成后，父子进程的虚拟内存相同，都映射到相同的物理内存，不必为子进程复制一份物理内存。当父进程或者子进程需要对某部分**物理内存进行写入时**，才会为子进程复制对应的物理内存，**确保不同进程的物理内存的独立**。



#### 实现原理：

​	fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会**把触发的异常的页复制一份**，于是父子进程各自持有独立的一份。



#### 总结

​	写时复制可以减少无谓的物理内存开销，当两个进程的虚拟内存共享同一块物理内存，除非有进程对内存进行了写操作，才需要复制共享内存，确保每个进程私有空间的独立。



### 碎片

#### 內部水平（内存对其产生）

​	内部碎片是由于系统**分配给进程的空间大于其所申请的大小**，处于（操作系统分配的用于装载某一进程的内存）区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。



#### 外部碎片（频繁分配产生）

​	外部碎片指的是还没有被分配出去（不属于任何进程），但**由于太小了无法分配**给申请内存空间的新进程的内存空闲区域，即处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。	



## 动态内存分配

### 隐式空闲链表



### 显式空闲链表



### 分离的空闲链表

​	维护多个空闲链表，每个链表存放大致相等大小的内存块。

#### 简单分离存储

​	不分割，不合并，很容易造成内部和外部碎片

#### 分离适配

​	可分割可合并

##### 伙伴系统

​	伙伴系统（buddy system）是**以页为单位**管理和分配**物理内存**。分离适配的特例，每个链表都是2的幂大小，最大可以申请1024个连续页框，对应4MB大小的连续内存。递归分割，分割出来的页被插入到对应的空闲链表中。释放一个块时，会合并空闲的伙伴。当遇到一个已经分配的伙伴，停止合并。

​	伙伴：二进制值只有相同位上值不同地址

​	优点：它可以快速搜索和快速合并，减少外部碎片。



##### Slab

​	slab分配器分配物理内存**以Byte为单位**。但是slab分配器并没有脱离伙伴系统，而是基于伙伴系统分配的大内存进一步细分成小内存分配，**减少内部碎片的产生**。

​	kmem_cache是一个cache_chain的链表，描述了一个高速缓存，每个高速缓存包含了一个slabs的列表，这通常是一段连续的内存块。存在3种slab：

- slabs_full(完全分配的slab)

- slabs_partial(部分分配的slab)

- slabs_empty(空slab,或者没有对象被分配)。

  

​	slab是slab分配器的最小单位，在实现上一个slab有一个货多个连续的物理页组成（通常只有一页）。单个slab可以在slab链表之间移动，例如如果一个半满slab被分配了对象后变满了，就要从slabs_partial中被删除，同时插入到slabs_full中去。

![1677163633863](C:\Users\Chenhui\AppData\Roaming\Typora\typora-user-images\1677163633863.png)





## 问题

**Q：为啥缺页就发生页面调度，应该只发生在物理内存不够的情况下吧？如果内存还够，直接在页表添加映射关系更加合理吧？**涉及到内存分配的过程？

应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。

缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。

如果没有空闲的物理内存，那么内核就会开始进行**回收内存**的工作，回收的方式主要是两种：直接内存回收和后台内存回收。

- **后台内存回收**（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——**触发 OOM （Out of Memory）机制**。

OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。

![img](https://img-blog.csdnimg.cn/2f61b0822b3c4a359f99770231981b07.png)