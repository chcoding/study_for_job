# 数论

## 求约数个数

[反素数详解](https://www.acwing.com/video/51/)

### 特性

举个例子`300 = 2^2*3^1*5^2`

1. 每个数字可以分解为每个质数指数次的乘积，假设每个指数次数分别为`i1,i2,i3...`
2. 约数总数等于`(i1+1) * (i2+1) * (i3+1) * .... *(in+1)`
3. 对于int类型，2的30次是最大的指数次了。



##### 反素数额外特性

定义：对于任何正整数 x，其约数的个数记作 g(x)，例如 g(1)=1、g(6)=4。

如果某个正整数 x满足：对于任意的小于 x 的正整数 i，都有 g(x)>g(i)，则称 x为反素数。

1. 一定是2 * 3 * 5 * ...从小到大连续质数的积。（如果`2*3*7`如果是约数最大，那之前`2*3*5`约数一样多，不满足反素数约数最多的定义）
2. 小质数的指数次 一定>= 大质数的指数次
3. 不超过int，`c1+c2+c3+...+cn < 30`(2^31就是超出了)

![1675693252973](C:\Users\Chenhui\AppData\Roaming\Typora\typora-user-images\1675693252973.png)

利用这些特性就通过暴力搜索（dfs）的方式推断出<n的所有质数

```c++
#include<iostream>
#include<cstring>
// #include<cstdio>由于这个题目的读入量很小，所以我们完全可以用cin来读
#include<algorithm>

using namespace std;

int primes[9]={2,3,5,7,11,13,17,19,23};//primes的话一共是有9个对吧

typedef long long LL;//当然这里要加一个long long 啊

int maxd;//比方说我们的约数个数可以记为我们的maxd

int number;//然后数本身的话可以记成number

int n;//然后还有一个n对吧，这是我们读入的这个数


//u指定那个质数，last对应其最大可选的指数次数，p是当前乘积，s是当前约数个数
//根据反素数的定义，last小于等于前一个指数的次数，上一层为多少，这一层最大值就为多少
void dfs(int u,int last,int p,int s)//好，那我们dfs一下,上一个的次数，上一个数，以及我们的约数个数
{
    //好，然后如果我们当前的约数个数是大于我们的最大约数个数了
    //或者是等于等于最大约数个数并且p小于number的话
    if(s>maxd||s==maxd&&p<number)
    {
        maxd=s;//我们就要更新一下
        number=p;//然后number等于p，对吧
    }
    //好，接下来的话就去枚举一下啊
    //当然这里我们要判断一下啊，如果u已经的等于9了，表示已经枚举了所有情况了，那么我们就可以直接return了
    if(u==9)return;
    //然后接下来去枚举一下次数
    //次数的话咱们从一次开始枚举，一直枚举到第，last次对吧，不能比上一次多
    for(int i=1;i<=last;i++)
    {
        if((LL)p*primes[u]>n)//那每次都先算一下我们这个这个，p乘上一个我们当前的质数，看一下是不是已经大于n了
        break;//大于n的话那就直接break就可以了对吧
        //好，然后否则的的话，咱们就让p就乘上一个primes[u]
        p*=primes[u];
        //好然后再dfs下一次
        dfs(u+1,i,p,s*(i+1));//u+1,然后是这个i，对吧，p,还有这个s*(i+1);
        //好，然后我们来调试一下
    }
}

int main()
{
    cin>>n;
    /*字            幕        开          始*/
    //首先dfs一遍
    //那么dfs里面是有几个参数呢？
    //第一个是我们枚举到第几个质数了，第0个对吧，从第0个开始枚举
    //然后下一个的话是我们的次数最大是多少对吧，那我们刚刚说了次数最大是30对吧，当前最大次数是30
    //然后我们这个数本身乘积是多少？这个乘积本身是1对吧
    //好，然后...（y总摸了摸鼻子和嘴唇继续说）呃...下一个，下一个应该是约数个数对吧，约数个数的话最开始是1对吧
    //因为我们约数个数是通过公式来算的，每次都要乘上一个数，所以在没乘之前应该是1
    dfs(0,30,1,1);
    //哦，忘记输出了咱们，咱们要把这个答案输出

    cout<<number<<endl;
    cout << maxd << endl;
    //好，840对吧，没问题
    return 0;
}
```

