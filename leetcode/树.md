# 树

## 存储方式

### 1. 邻接表

​	每个父节点的所有子节点用一条链表维护。



#### 具体实现

##### 数据结构

`int e[N]`：节点的信息	`idx ---> node`

`int ne[N]`：维护链表，返回当前子节点的下一个子节点，`ne[idx1] ---> idx2`

`int h[N]`：hash的功能，返回父节点其子节点链表的第一个节点下标 `h[node] = idx`

`int idx`：下标，累加

```c++
int e[N];
int ne[N];
int h[N];
int idx；
```



##### 操作

添加一对父子关系

1. `e[idx] = i`	新增一个子节点，增加下标和node的映射
2. `ne[idx] = h[p]`	新子节点指向原来的头子节点
3. `h[p] = idx`	更新链表头节点

```C++
//p:parent i:son
//p和i可以换成具体的节点node
void add(int p, int i) {
	e[idx] = i;	//新增一个子节点，给定下标idx
   	   ne[idx] = h[p];	//新子节点指向原来的头子节点
        h[p] = idx++;	//更新链表的头节点
}
```



遍历某个父节点p的所有子节点i

通过h[p]找到第一个头一个子节点后，再通过ne数组维系的子节点链表关系找到所有子节点。

```c++
for (int i = h[p]; i != -1; i = ne[i])
{
    ...
}
```





