# [MVCC](https://juejin.cn/post/7016165148020703246)

​	为了解决并发事务存在的**脏读、不可重复读、幻读**等问题，数据库设计了四种隔离级别。分别是**读未提交，读已提交，可重复读，串行化（Serializable）**。数据库隔离级别读**已提交、可重复读** 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。

​	MVCC，即**Multi-Version  Concurrency Control （多版本并发控制）**。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

> 通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。



## 快照在MVCC如何工作

### 快照读和当前读

**快照读：** 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：

```mysql
select * from core_user where id > 2;
```

**当前读**：读取的是记录数据的最新版本，显式加锁的都是当前读（更新操作也是当前读）

```mysql
select * from core_user where id > 2 for update;
select * from account where id>2 lock in share mode;
```



###  Read View

- **Read View是什么呢？** 它就是事务执行SQL语句时，产生的读视图。实际上在innodb中，每个SQL语句执行前都会得到一个Read View。
- **Read View有什么用呢？** 它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~

Read View是如何保证可见性判断的呢？我们先看看Read view 的几个重要属性

- m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。
- min_limit_id:表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。
- max_limit_id:表示生成ReadView时，系统中应该分配给下一个事务的id值。
- creator_trx_id: 创建当前read view的事务ID



**Read view 匹配条件规则**：

1. 如果数据事务ID `trx_id < min_limit_id`，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。
2. 如果`trx_id>= max_limit_id`，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。
3. 如果 `min_limit_id =<trx_id< max_limit_id`，需要分3种情况讨论

> - （1）.如果`m_ids`包含`trx_id`,则代表Read View生成时刻，这个事务还未提交，但是如果数据的`trx_id`等于`creator_trx_id`的话，表明数据是自己生成的，因此是**可见**的。
> - （2）如果`m_ids`包含`trx_id`，并且`trx_id`不等于`creator_trx_id`，则Read   View生成时，事务未提交，并且不是自己生产的，所以当前事务也是**看不见**的；
> - （3）.如果`m_ids`不包含`trx_id`，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是可见的。



#### Read View何时创建

读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是**创建一致性视图的时间点不同**

1. 在可重复读隔离级别下，只需要在**事务开始的时候创建一致性视图**，之后事务里的其他查询
   都共用这个一致性视图；
2. 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。



#### 可见视图判断准则

​	如果一个数据版本是在一致性视图前前生成的，就认；如果是在一致性视图后才生成的，就不认，必须要找到它的上一个版本”。

有三种情况：
1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。



#### 可重复读隔离级别

##### 情况一：

|            事务A=100            |                 事务B=101                  |
| :-----------------------------: | :----------------------------------------: |
|             1.begin             |                                            |
|                                 |                  2.begin                   |
|                                 | 3.update T set k = 66 where name = 'yang'; |
|                                 |                  4.commit                  |
| 5.select * from T where k > 20; |                                            |
|            6.commit             |                                            |

**结果：**事务B的修改操作在事务A的查询结果可见。



###### 分析

`begin`执行的时候，事务并未开始；可重复读的read view在事务开始的时候创建，并且同一个事务使用的相同的read view。

如果`beign`替换为`start transaction with consistent snapshot `，则read view在事务B开启前就创建了。满足判断条件2（视图创建后提交的版本）不可见。

| 变量           | 值   |
| -------------- | ---- |
| 变量           | 100  |
| max_limit_id   | 102  |
| min_limit_id   | 100  |
| creator_trx_id | 100  |

> min_limit_id(100)=<trx_id（101）<max_limit_id（102)*;*
> 但是,trx_id=101，不属于m_ids集合



##### 情况二：

|            事务A=100            |                 事务B=101                  |
| :-----------------------------: | :----------------------------------------: |
|             1.begin             |                                            |
|                                 |                  2.begin                   |
| 3.select * from T where k > 20; |                                            |
|                                 | 4.update T set k = 66 where name = 'yang'; |
|                                 |                  5.commit                  |
| 6.select * from T where k > 20; |                                            |
|            7.commit             |                                            |

**结果：**事务B的修改操作在事务A的查询结果不可见。



###### 分析

事务A在步骤3创建一致性视图，事务B的修改是在视图后提交的，所以不可见。

| 变量           | 值        |
| -------------- | --------- |
| 变量           | {100,101} |
| max_limit_id   | 102       |
| min_limit_id   | 100       |
| creator_trx_id | 100       |

> min_limit_id(100)=<trx_id（101）<max_limit_id（102);
> 因为m_ids{100,101}包含trx_id（101），
> 并且creator_trx_id (100) 不等于trx_id（101）



##### 总结

​	在可重复读隔离级别下，在**事务开始的时候创建一致性视图**，之后事务里的其他查询都共用这个一致性视图。

​	`begin/start transaction `命令并不是一个事务的起点，在执行到它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用`start transaction with consistent snapshot `这个命令。



### 事务的可重复读的能力是怎么实现的？

​	可重复读的核心就是一致性读（consistent read）；而**事务更新数据的时候，只能用当前读**。如
果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

​	**普通查询语句是一致性读，一致性读会根据数据版本的`rowtrx_id`和一致性视图确定数据版本的可见性。**



### 幻读

**幻读**：幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。



**脏读与不可重复读的区别**：

1. 前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。
2. 不可重复读指的是多次读取的数据值不同，而幻读则是多次查询结果的数量不同。



#### MySQL 可重复读隔离级别，完全解决幻读了吗？

对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png)

​	在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。

​	**可重复读解决了绝大部分的幻读，但是仍然存在特殊情况。**