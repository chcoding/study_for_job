## 语法

### 构造函数

#### 类内初始值

​	类内初始值用于初始化数据成员，没有初始值的成员将被默认初始化（定义于函数体外的变量初始化为0，定义于函数体内的内置类型的对象如果没有初始化，其值未定义。类对象没有显示初始化，其值由类确定）。



**只有当类没有声明任何的构造函数，编译器才会自动生成默认构造函数。**

Q：什么情况下，不能依赖于默认生成的构造函数？

A：如果类中包含类成员，且该成员的类没有默认构造函数，编译器将无法初始化该成员。



通过 `= default`能要求编译器生成默认构造函数，这和自动生成的默认构造函数等效。

成员的初始化通过初始化列表来实现，在函数体执行之前完成的，并且按照其在类中**定义的顺序**进行。

const、引用成员或者是未提供默认构造函数的类成员必须通过初始化列表来为这些成员提供初值。

### 析构函数

​	析构函数释放对象使用的资源，并销毁对象非static数据成员。

​	析构函数中，首先执行函数体，然后销毁成员，成员按照**定义顺序的逆序**销毁。析构函数中成员销毁是**隐式完成**的（**函数体是作为销毁步骤之外的另一部分进行的，除了通过new分配的内存，需要在函数体delete来销毁**）。销毁类类型的成员需要执行成员的析构函数，内置类型没有析构函数，因此销毁内置类型什么也不需要做。

> 销毁一个类对象指针的成员不会delete它所指向的对象。

​	与普通指针不同，**智能指针**是类类型，会通过析构函数**自动销毁**。

#### 何时调用析构函数

1. 变量离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
4. 动态分配的对象，其对应指针应用delete运算时被销毁

#### 三/五法则

​	如果一个类需要**自定义**析构函数，几乎可以确定它也需要自定义拷贝构造函数和拷贝赋值运算符（移动构造和移动赋值运算符）。



### 函数重载

定义：如果同一个作用域内的函数名相同但形参列表不同，称为函数重载。

**如果两个函数只有返回类型不同外其他要素均相同，这两个函数不属于重载，且编译报错。**



#### const形参和重载

>  顶层const：变量本身就是常量
>
> 底层const：指针或者引用指向的变量是常量

顶层const和非顶层const形参不能用于函数重载

```c++
//不属于函数重载，重复声明
int f(int);
int f(const int);
```



底层const和非底层const形参能用于函数重载

```c++
//属于函数重载
int f(int *);
int f(const int *);

int f(int &);
int f(const int &);
```

同理，类的成员函数可以基于const进行重载

原因在于常量对象只能调用常量成员函数，而非常量对象则会优先调用非常量版本的成员函数。

```C++
//基于const进行重载
int f()const {}
int f(){}
```



### 指针作为参数，也是值传递

把指针作为函数的参数其实也是值传递。函数内修改指针的值，其实修改的是指针的副本。

**参数传指针，一般目的是修改其指向的数据。**

```c++
#include <iostream>
using namespace std;

void change(int *p)
{
	p = new int(20);
	cout << *p << endl; //20
}

int main()
{
      int *p = new int(10);
      cout << *p << endl;//10
      change(p);
  	cout << *p << endl;//10
}
```



### const限定符

#### const对象

一旦创建后就不能改变其值了，必须**初始化**。

由于创建后就不能改变其值了，只支持那些不修改值的操作。

1. 运算
2. 初始化
3. 赋值

```C++
#include <iostream>
using namespace std;

int main()
{
	int k = 20;
	const int i = k;
	int j = i;
	cout << i << " " << j << endl;		//20 20
	j += i;
	cout << i << " " << j << endl;		//20 40
   return 0;
}
```

### 

#### 顶层const和底层const

顶层const：变量本身就是常量

底层const：指针或者引用指向的变量是常量



当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。

1. 顶层const不受影响
2. 底层const存在限制：拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转化。（**非常量可以转换为常量**）



#### 对常量的引用、指向常量的指针、常量指针

没有指针常量的说法

**对常量的引用、指向常量的指针**

1. 对常量的引用、指向常量的指针**可以绑定非常量对象（只是编译器认为指向的是常量，不能通过引用和指针修改指向的值）**，但可以通过其他途径修改。
2. 常量只能绑定在常量引用，存常量对象的地址只能用指向常量的指针。

对于第一点的解释，可以参考C++ prime144页，这里发生了非常量指针到常量指针的转换，但是不允许常量指针转换为非常量指针。

```c++
int i = 10;
const int j = 20;

int &xx = i;		//1.true，类型相同，都不是常量
const int &x = i;	//2.true，可以绑定非常量对象
const int &y = j;	//3.true，类型相同，都是常量
int & yy = j;	//4.false,常量对象只能用常量引用绑定
int yyy = j；	//true，常量赋值并不影响他的值，允许

int *p1 = &i;	//true
const int *p2 = &i；	//5.true
const int *p3 = &j;	//6.false，只能用指向常量的指针存常量对象的地址
int *p4 = &j;	//6.false，只能用指向常量的指针存常量对象的地址
```



**常量指针**

把*放在const前表示指针是一个常量

`int  *const i =&val `

指针本身是一个常量，**指针指向不能变，但可以通过指针修改指向的值**。



> ①[const int p](https://www.zhihu.com/search?q=const int p&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A44950608}); 
>
> ②const int* p; 	//p is a point to int const
>
> ③int const* p; 	//p is a point to const int
>
> ④int * const p;	//p is a const point to int
>
> ⑤const int * const p;	//p is a const point to int const.
>
> ⑥int const * const p;	//p is a const point to const int

从右往左读，遇到p就替换成“p is a ”遇到*就替换成“point to”。



#### constexpr变量

声明为constexpr类型的变量一定是一个常量，而且必须用常量表达式初始化。

constexpr声明指针时，就是把指针设置为了顶层const（定义对象本身是常量，其指向对象无关）



#### 常量成员函数

> **常量成员函数不能改变对象的值**
>
> 返回*this，返回类型将是常量引用，const X & f()const {}

##### 定义

在参数列表和函数体之间插入const，表示this是一个**指向常量**的常量指针（this本来就是常量指针，指向特定的类对象），`const class_name * const this`

`void ClassType::func_name() const{}`



##### 作用

常量对象只能调用常量成员函数，非常量对象既可以调用常量成员函数，也可以调用非常量成员函数。（**只能用指向常量的指针，存放常量对象的地址**）。



### 内联函数(inline)

内联函数会编译的时候展开，可以避免函数调用的开销，适合调用频繁，规模小的函数。

`inline`要和函数定义放在一起才有效。

定义在类内的函数，默认自动为inline函数。



### 友元

每个类负责直接控制自己的友元类或者友元函数。因此**友元关系不能被传递（也不能被继承）**，例如类A是类C的友元类，类B是类A的友元类，但是类B不是类C的友元类。

友元声明不等于声明，如果友元函数在类内部定义，如果类外使用，则需要重新定义

```C++ 
struct x{
    friend void f(){}
    X () {f{};}
    void g();
    void h();
}

void X::g() {f();}	// false，f没有声明
void f();
void X::h() {f();}	//true，f进行了声明
```



### auto、decltype

都属于C++11的特性。

#### auto

通过时初始值来推算变量的类型，例如`auto i = 10;`

使用auto在一条语句中可以声明多个变量，但是所有变量基本数据类型需要一样（例子4,5）。

auto一般会忽略顶层const（例子1），如果希望推断出的是顶层const，需要明确支持（例子2）。

```c++
int i = 10;
const int &j = i;
auto l = j;	//1）int l，忽略顶层const和引用
const auto l = j;	//2）const int l，忽略顶层const和引用
auto &ll = j;//3）const int *ll，auto的引用会保留顶层const

auto sz = 0, pi = 3.14;		//4），false，sz和pi的数据类型不同
auto j = 0, *p = &j;		//5），true，j和p的数据类型不同
```



#### decltype

返回操作数的返回类型，例如`decltype(i) j = 20;`。

遵循以下准则：

1. 返回变量的底层const和引用
2. 对左值变量使用decltype，会返回引用类型

```c++
decltype(*p3) c = i;	//int &c，*p3是左值，返回引用
decltype ((i)) cc = i;	//int &cc，(i)被编译器当做了表达式，变量是可以作为左值的特殊表达式
```



#### 区别

处理顶层const和引用的方式不同

1. auto会忽略顶层const和引用（**auto &会保留底层const**），只保留底层；decltype包含顶层const和引用

```c++
int i = 10;
const int &j = i;
auto l = j;	//int l，忽略顶层const和引用
auto &ll = j;//const int *ll，auto的引用会保留顶层const
decltype(j) m = i;	//const int &m，decltype保留顶层const和引用

const int* const p = &i;
auto p1 = p;	// const int *p1，保留底层const
decltype(p) p2 = p;		//const int* const p2，顶层和底层都保留
int *p3 = &i;
```



### 左值和右值

当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存的位置）。

使用decltype的时候，左右值表现也有所不同，**作用于左值将返回引用类型**。



### 字符数组、字符串字面值

字符串字面值是由C继承而来的C风格字符串，以空字符串`\0`结束。C++中提供cstring头文件操作字符串字面值。

可以用字符串字面值初始化字符数组，空字符也会被拷贝到字符数组中。

`char a[] = "C++";`，其中a的大小为4，最后是一个空字符串。

**不同能用string对象直接初始化指向字符的指针，需要通过string的c_str()方法，其返回const char*指针。**



### 隐式的类类型转换

如果构造函数只接受一个实参，则它定义了转换为此类类型的隐式转换机制。不过只允许一步类型转换。

```c++
string null_book = "9-999-99999-99";
//Sales_data (const std::string &s)
//void Sales_data::add(Sales_data)
add(null_book) 	//合法，进行了隐式类型转换，用null_bool创建了Sale_data对象，传递给add
```



#### 抑制类类型的隐式转换explicit

通过将构造函数声明为explicit可以阻止隐式类型转换，只对一个实参的构造函数有效，且explicit只能在类内声明函数出现，类外定义不应重复。

explicit不影响显性初始化

```c++
//explicit Sales_data (const std::string &s)
//void Sales_data::add(Sales_data)
add(null_book) 	//不合法，进行了隐式类型转换，用null_bool创建了Sale_data对象，传递给add
add(Sale_data(null_book));	//合法，显性的类型转化
```



### 类的静态成员static

static出现在类内部的声明语句，类外定义时不能重复出现。

静态成员存在于任何对象之外，不占用类对象的存储空间。**其定义在任何函数之外（一般不在类内初始化，除非是constexpr）**

静态成员函数也不与任何对象绑定，不包含this指针，因此也不能声明为const。



### 其他

1. C++11规定商一律向0取整
2. 一条表示并不会规定求值顺序，`int i =0; cout << i << " " << i++ << endl`会出现未定义的错误，因为无法确定`i`和`i++`那个先求值。只有`||`、`&&`、`?:`和`,`这四个运算符确定求职顺序。

****



### I/O数据流

IO对象无拷贝或赋值，因此不能把形参或返回类型设置为IO数据流，而是用引用的方式返回。



## 操作系统

#### 1、字节序

大端序：将数据的低位放在内存高位地址，数据的高位放在内存低位地址上。（网络字节序）

小端序：将数据的低位放在内存低位地址，数据的高位放在内存高位地址上。（主机）



Linux socket网络编程中，经常会使用下面四个C标准库函数进行字节序间的转换。

> #include <arpa/inet.h>
> uint32_t htonl(uint32_t hostlong);      //把uint32_t类型从主机序转换到网络序
> uint16_t htons(uint16_t hostshort);     //把uint16_t类型从主机序转换到网络序
> uint32_t ntohl(uint32_t netlong);       //把uint32_t类型从网络序转换到主机序
> uint16_t ntohs(uint16_t netshort);      //把uint16_t类型从网络序转换到主机序





## C++11特性

### 列表初始化

​	要定义一个名为`units_sold`的int变量并且初始化为0，以下语句均可

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold(0);
int units_sold{0};
```

其中2，4通过花括号来初始化变量，这种形式被称为列表初始化。

​	这种初始化形式有一个重要的特点：存在信息丢失风险时，编译器会报错

```c++
long double id = 3.1415926;
int a{ld}, b = {ld};	//转换未执行，因为存在丢失信息的风险。
```



### =delete

​	在函数参数列表后加上`= delete`，可以定义函数为删除的。主要用途是禁止拷贝或者禁止函数调用。