# 智能指针

## 动态分配内存

​	C++定义了两个运算符来分配和释放内存，new运算符用来申请内存，delete运算符用来释放内存。**动态内存的生命周期直到被释放为止。**

### new

​	使用new动态分配和初始化内存，new在内存不足，无法分配的时候会抛出bad_alloc的异常。

```c++
int *p1 = new int;	//默认初始化，内置类型默认初始化是未定义的；类对象调用默认构造函数
int *p2 = new int();	//值初始化， 默认为0
const int* pci = new const int(1024);
const string *pcs = new const string;
```



#### 动态分配数组

​	通过new在类型后面跟一对方括号，在其中指明要分配的对象的数目。数目必须是整数，但不必是常量。要注意的是，**分配一个数组得到的是一个元素类型的指针。**

​	在分配数组大小后面加一对()，可对数组中的元素进行值初始化。还可以用初始化了列表{}进行初始化。

```c++
int *pia = new int[10];		//默认初始化
int  *pia2 = new int[10]();		//值初始化，初始值为0
int *pia3 = new int[10]{1,2,3,4}
```



#### 标准库allocator

​	allocator也是一个模板，可以将内存分配和对象构造分离开来。



### delete

​	delete运算符用来把动态内存归还给系统，销毁给定的指针指向的对象；释放对应的内存。



#### 释放动态数组

​	动态释放数组，需要在指针前面加一个[]，数组的元素按照**逆序**销毁，然后释放内存。

C++可以在堆中动态申请内存，动态对象的生存周期由程序来控制，当动态内存不在使用时，需要显式的回收内存。

​	动态使用内存的会带来问题：

1. 在不使用内存后，忘记释放内存，就会导致内存泄露。
2. 在尚有指针引用内存的情况就释放了它，会导致空悬指针的出现，这些指针会非法使用内存。



​	为了更加安全的使用动态内存，新的标准库提供两种智能指针类型来管理动态对象。智能指针的行为类似常规指针，区别在于它**负责自动释放所指向的对象**。

1. shared_ptr允许多个指针指向同一个对象；
2. unique_ptr则独占所指向的内存。





## share_ptr

​	允许多个指针指向同一个对象，可以认为每个shared_ptr都有一个关联的计数器，通常称为引用计数。一旦一个shared_ptr的计数器变为0，就会自动释放自己所管理的内存。

> 到底用一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库实现。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。

​	

计数器何时增加

1. 拷贝一个shared_ptr，计数器都会增加
2. 用一个shared_ptr1初始化另外一个shared_ptr2
3. 作为参数传递给函数或者作为函数返回值，计数值增加



计数器何时减少

1. 离开作用域
2. 赋予一个新值
3. shared_ptr被销毁



​	最安全的分配和使用动态内存的方法是**调用一个名为make_shared的标准库函数**。

```
make_shared <T> (args)
shared_ptr<int> p2(new int(1024));	//用new返回的指针初始化智能指针，必须使用直接初始化
```



### 使用注意点

1. 使用**内置指针访问一个智能指针**所负责的对象是很危险的，因为无法知道对象何时会释放。
2. 不要使用get初始化另一个智能指针或者为另一个智能指针赋值。



### 特殊用法

**自定义删除方式：**

​	对于为C和C++共同设计的类，不存在析构函数，需要显式释放内存。比如网络库connect后，需要显式调用disconnect。这时候可以显式规定我们的释放操作。参考c++ prime416页。



### 实现

关键：

1. 引用计数**采用int类型指针**，这是由于需要指向同一个对象的shared_ptr共享
2. 实现拷贝构造、赋值（减少原智能指针的引用计数，增加新指针的引用计数）、析构函数、重构*和->运算符。



## unique_ptr

​	一个unique_ptr拥有它所指向的对象，只能有一个unique_ptr指向一个给定对象，当指针被销毁，所指向的对象也被销毁。

​	**没有类型make_shared的函数返回一个unique_ptr，定义一个unique_ptr需要将其绑定到一个new返回的指针上。**

​	unique_ptr不支持拷贝或者赋值操作，但是可以通过release和reset操作把指针的所有权从一个unique_ptr转移给另一个unique_ptr。

```
u.release();	//u放弃对指针的控制权，返回指针，并将u置空
u.reset()	//释放u所指向的对象
u.reset(p)	//如果提供了内置指针p，u指向该对象
    
//转移
unique_ptr<string> p2(p1.release());
p2.reset(p3.release());
```



## weak_ptr

​	weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr**不会改变shared_ptr的引用计数**。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。

​	由于对象可能不存在，不能直接用weak_ptr直接访问对象，**必须调用lock**。此函数检查weak_ptr指向的对象是否存在，若存在，返回一个指向共享对象的shared_ptr。



